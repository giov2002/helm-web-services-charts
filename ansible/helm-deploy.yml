name: ğŸš€ Helm Charts Deployment (CD)

on:
  # DÃ©clenchement manuel via l'interface GitHub
  workflow_dispatch:
    inputs:
      deployment_type:
        description: 'Type de dÃ©ploiement'
        required: true
        default: 'single-service'
        type: choice
        options:
        - single-service
        - full-stack
        - priority-based
      
      target_service:
        description: 'Service Ã  dÃ©ployer (si single-service)'
        required: false
        default: 'bind9'
        type: choice
        options:
        - bind9
        - unbound
        - mysql
        - phpmyadmin
        - web-apache
        - web-nginx
        - email
        - monitoring
      
      environment:
        description: 'Environnement cible'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      
      force_recreate:
        description: 'Forcer la recrÃ©ation des ressources'
        required: false
        default: false
        type: boolean

env:
  NAMESPACE_PREFIX: dev
  KUBECONFIG_PATH: /tmp/kubeconfig

jobs:
  # Job 1: PrÃ©paration de l'environnement
  prepare-deployment:
    name: ğŸ“‹ PrÃ©paration DÃ©ploiement
    runs-on: self-hosted  # Votre machine Debian avec Minikube
    outputs:
      services_to_deploy: ${{ steps.planning.outputs.services_to_deploy }}
      deployment_order: ${{ steps.planning.outputs.deployment_order }}
      target_namespace: ${{ steps.planning.outputs.target_namespace }}
    
    steps:
      - uses: actions/checkout@v4

      - name: ğŸ” VÃ©rification de l'environnement
        run: |
          echo "ğŸ—ï¸ === VÃ‰RIFICATION ENVIRONNEMENT ==="
          echo "OS: $(lsb_release -d | cut -f2)"
          echo "Docker: $(docker --version)"
          echo "Minikube: $(minikube version --short)"
          echo "Kubectl: $(kubectl version --client --short)"
          echo "Helm: $(helm version --short)"
          
          # VÃ©rification Minikube actif
          if ! minikube status > /dev/null 2>&1; then
            echo "âŒ Minikube n'est pas actif"
            echo "DÃ©marrage de Minikube..."
            minikube start --driver=docker --memory=4096 --cpus=2
          else
            echo "âœ… Minikube actif"
          fi
          
          # Configuration kubectl
          minikube update-context
          kubectl cluster-info

      - name: ğŸ“‹ Planification du dÃ©ploiement
        id: planning
        run: |
          # DÃ©finition des services et prioritÃ©s
          declare -A services=(
            [bind9]="1:dns"
            [unbound]="1:dns" 
            [mysql]="2:database"
            [phpmyadmin]="3:database"
            [web-apache]="2:web"
            [web-nginx]="2:web"
            [email]="4:email"
            [monitoring]="5:monitoring"
          )
          
          # DÃ©finition des dÃ©pendances
          declare -A dependencies=(
            [phpmyadmin]="mysql"
            [email]="mysql"
            [monitoring]="mysql"
          )
          
          deployment_type="${{ github.event.inputs.deployment_type }}"
          target_service="${{ github.event.inputs.target_service }}"
          environment="${{ github.event.inputs.environment }}"
          
          echo "ğŸ¯ Type de dÃ©ploiement: $deployment_type"
          echo "ğŸ¯ Service cible: $target_service"
          echo "ğŸ¯ Environnement: $environment"
          
          # GÃ©nÃ©ration de la liste des services Ã  dÃ©ployer
          if [[ "$deployment_type" == "single-service" ]]; then
            services_list="[\"$target_service\"]"
            order_list="[\"$target_service\"]"
          elif [[ "$deployment_type" == "full-stack" ]]; then
            services_list='["bind9","unbound","mysql","phpmyadmin","web-apache","web-nginx","email","monitoring"]'
            order_list='["bind9","unbound","mysql","web-apache","web-nginx","phpmyadmin","email","monitoring"]'
          else
            # Priority-based
            services_list='["bind9","unbound","mysql","web-apache","web-nginx","phpmyadmin","email","monitoring"]'
            order_list='["bind9","unbound","mysql","web-apache","web-nginx","phpmyadmin","email","monitoring"]'
          fi
          
          echo "services_to_deploy=${services_list}" >> $GITHUB_OUTPUT
          echo "deployment_order=${order_list}" >> $GITHUB_OUTPUT
          echo "target_namespace=${environment}" >> $GITHUB_OUTPUT
          
          echo "ğŸ“¦ Services Ã  dÃ©ployer: $services_list"
          echo "ğŸ“Š Ordre de dÃ©ploiement: $order_list"

  # Job 2: CrÃ©ation des namespaces
  setup-namespaces:
    name: ğŸ—ï¸ Setup Namespaces
    runs-on: self-hosted
    needs: prepare-deployment
    
    steps:
      - name: ğŸ—ï¸ CrÃ©ation des namespaces
        run: |
          namespaces=("dns" "database" "web" "email" "monitoring")
          env="${{ needs.prepare-deployment.outputs.target_namespace }}"
          
          for ns in "${namespaces[@]}"; do
            full_ns="${env}-${ns}"
            echo "ğŸ”§ CrÃ©ation/VÃ©rification namespace: $full_ns"
            
            kubectl create namespace "$full_ns" --dry-run=client -o yaml | kubectl apply -f -
            kubectl label namespace "$full_ns" environment="$env" --overwrite
            kubectl label namespace "$full_ns" managed-by="helm-cd" --overwrite
          done
          
          echo "ğŸ“‹ Namespaces disponibles:"
          kubectl get namespaces -l managed-by=helm-cd

  # Job 3: DÃ©ploiement des services
  deploy-services:
    name: ğŸš€ DÃ©ploiement Services
    runs-on: self-hosted
    needs: [prepare-deployment, setup-namespaces]
    strategy:
      matrix:
        service: ${{ fromJson(needs.prepare-deployment.outputs.services_to_deploy) }}
      fail-fast: false
      max-parallel: 2
    
    steps:
      - uses: actions/checkout@v4

      - name: ğŸš€ DÃ©ploiement ${{ matrix.service }}
        run: |
          # Mapping service â†’ chart path
          declare -A paths=(
            [bind9]="bind9:dns"
            [unbound]="unbound:dns"
            [mysql]="database/mysql:database"
            [phpmyadmin]="database/phpmyadmin:database"
            [web-apache]="web-apache:web"
            [web-nginx]="web-nginx:web"
            [email]="email:email"
            [monitoring]="monitoring/monitoring-chart:monitoring"
          )
          
          service="${{ matrix.service }}"
          IFS=':' read -ra path_info <<< "${paths[$service]}"
          chart_path="${path_info[0]}"
          namespace_suffix="${path_info[1]}"
          
          env="${{ needs.prepare-deployment.outputs.target_namespace }}"
          namespace="${env}-${namespace_suffix}"
          release_name="${env}-${service}"
          
          echo "ğŸš€ === DÃ‰PLOIEMENT DE $service ==="
          echo "ğŸ“ Chart: $chart_path"
          echo "ğŸ·ï¸ Namespace: $namespace"
          echo "ğŸ·ï¸ Release: $release_name"
          
          # VÃ©rification de l'existence du chart
          if [[ ! -f "$chart_path/Chart.yaml" ]]; then
            echo "âŒ Chart.yaml non trouvÃ© dans $chart_path"
            exit 1
          fi
          
          # Configuration des values selon l'environnement
          values_args=""
          if [[ -f "$chart_path/values-${env}.yaml" ]]; then
            values_args="--values $chart_path/values-${env}.yaml"
            echo "ğŸ“„ Utilisation de values-${env}.yaml"
          fi
          
          # DÃ©ploiement avec Helm
          if [[ "${{ github.event.inputs.force_recreate }}" == "true" ]]; then
            echo "ğŸ”„ Suppression de la release existante..."
            helm uninstall "$release_name" -n "$namespace" --ignore-not-found
          fi
          
          echo "ğŸ”§ Installation/Mise Ã  jour..."
          helm upgrade --install "$release_name" "$chart_path" \
            --namespace "$namespace" \
            --create-namespace \
            --wait \
            --timeout 300s \
            $values_args \
            --set environment="$env" \
            --set nameOverride="$service" \
            --atomic
          
          # VÃ©rification du dÃ©ploiement
          echo "ğŸ” VÃ©rification du dÃ©ploiement..."
          helm status "$release_name" -n "$namespace"
          
          echo "ğŸ“‹ Resources dÃ©ployÃ©es:"
          kubectl get all -n "$namespace" -l app.kubernetes.io/instance="$release_name"
          
          echo "âœ… $service dÃ©ployÃ© avec succÃ¨s!"

  # Job 4: Tests post-dÃ©ploiement
  post-deployment-tests:
    name: ğŸ§ª Tests Post-DÃ©ploiement
    runs-on: self-hosted
    needs: [prepare-deployment, deploy-services]
    if: always()
    
    steps:
      - name: ğŸ§ª Tests de santÃ© des services
        run: |
          env="${{ needs.prepare-deployment.outputs.target_namespace }}"
          services_json='${{ needs.prepare-deployment.outputs.services_to_deploy }}'
          
          echo "ğŸ§ª === TESTS POST-DÃ‰PLOIEMENT ==="
          
          # VÃ©rification des pods
          echo "ğŸ” VÃ©rification des pods..."
          for namespace in $(kubectl get namespaces -l managed-by=helm-cd -o name | cut -d/ -f2); do
            echo "ğŸ“‹ Namespace: $namespace"
            kubectl get pods -n "$namespace" -o wide
          done
          
          # VÃ©rification des services
          echo ""
          echo "ğŸ” VÃ©rification des services..."
          for namespace in $(kubectl get namespaces -l managed-by=helm-cd -o name | cut -d/ -f2); do
            echo "ğŸ“‹ Services dans $namespace:"
            kubectl get svc -n "$namespace"
          done
          
          # Tests de connectivitÃ© basiques
          echo ""
          echo "ğŸ” Tests de connectivitÃ©..."
          failed_tests=0
          
          # Test DNS (si bind9 ou unbound dÃ©ployÃ©s)
          if echo "$services_json" | grep -q "bind9\|unbound"; then
            echo "ğŸ§ª Test DNS..."
            if kubectl get pods -l app=bind9 -A | grep -q Running; then
              echo "âœ… Bind9 is running"
            else
              echo "âš ï¸ Bind9 test failed"
              failed_tests=$((failed_tests + 1))
            fi
          fi
          
          # Test base de donnÃ©es (si mysql dÃ©ployÃ©)
          if echo "$services_json" | grep -q "mysql"; then
            echo "ğŸ§ª Test MySQL..."
            if kubectl get pods -l app=mysql -A | grep -q Running; then
              echo "âœ… MySQL is running"
            else
              echo "âš ï¸ MySQL test failed"
              failed_tests=$((failed_tests + 1))
            fi
          fi
          
          echo ""
          if [[ $failed_tests -eq 0 ]]; then
            echo "âœ… Tous les tests post-dÃ©ploiement ont rÃ©ussi!"
          else
            echo "âš ï¸ $failed_tests tests ont Ã©chouÃ©"
          fi

  # Job 5: Rapport final
  deployment-report:
    name: ğŸ“Š Rapport de DÃ©ploiement
    runs-on: self-hosted
    needs: [prepare-deployment, deploy-services, post-deployment-tests]
    if: always()
    
    steps:
      - name: ğŸ“Š GÃ©nÃ©ration du rapport final
        run: |
          echo "ğŸ“Š === RAPPORT FINAL DE DÃ‰PLOIEMENT ==="
          echo "ğŸ•’ Date: $(date)"
          echo "ğŸ—ï¸ Environnement: ${{ needs.prepare-deployment.outputs.target_namespace }}"
          echo "ğŸ¯ Type: ${{ github.event.inputs.deployment_type }}"
          echo "ğŸ“¦ Services: ${{ needs.prepare-deployment.outputs.services_to_deploy }}"
          
          echo ""
          echo "ğŸ“Š === STATUTS DES JOBS ==="
          echo "PrÃ©paration: ${{ needs.prepare-deployment.result }}"
          echo "DÃ©ploiement: ${{ needs.deploy-services.result }}"
          echo "Tests: ${{ needs.post-deployment-tests.result }}"
          
          echo ""
          echo "ğŸ” === Ã‰TAT FINAL DU CLUSTER ==="
          helm list -A
          
          echo ""
          echo "ğŸ¯ === ACCÃˆS AUX SERVICES ==="
          echo "Dashboard Minikube: minikube dashboard"
          echo "Port-forward exemple: kubectl port-forward svc/service-name 8080:80 -n namespace"
          
          # DÃ©termination du succÃ¨s global
          if [[ "${{ needs.deploy-services.result }}" == "success" ]]; then
            echo ""
            echo "ğŸ‰ === DÃ‰PLOIEMENT RÃ‰USSI ==="
            echo "âœ… Tous les services sont dÃ©ployÃ©s et fonctionnels!"
          else
            echo ""
            echo "ğŸ’¥ === DÃ‰PLOIEMENT PARTIELLEMENT Ã‰CHOUÃ‰ ==="
            echo "âš ï¸ VÃ©rifiez les logs des services en Ã©chec"
          fi
