#!/bin/bash

# Script d'installation et configuration CI pour projet Minikube + Helm
# AdaptÃ© pour Debian 12 avec Ansible, Docker, Kubernetes, Helm

set -e

# Configuration
PROJECT_NAME="helm-web-services-charts"
CHARTS_PATH="."

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

print_header() {
    echo -e "${PURPLE}========================================${NC}"
    echo -e "${PURPLE}ğŸš€ SETUP CI MINIKUBE + HELM PROJECT${NC}"
    echo -e "${PURPLE}========================================${NC}"
    echo ""
}

print_step() {
    echo -e "${BLUE}ğŸ“‹ $1${NC}"
}

print_success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

print_error() {
    echo -e "${RED}âŒ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}âš ï¸ $1${NC}"
}

print_info() {
    echo -e "${BLUE}â„¹ï¸ $1${NC}"
}

check_prerequisites() {
    print_step "VÃ©rification des prÃ©requis..."
    
    # OS Check
    if [[ ! -f /etc/debian_version ]]; then
        print_warning "Ce script est optimisÃ© pour Debian 12"
    else
        print_success "OS: Debian $(cat /etc/debian_version)"
    fi
    
    # Outils requis
    local tools=("docker" "minikube" "kubectl" "helm" "ansible" "git" "curl" "jq")
    local missing=()
    
    for tool in "${tools[@]}"; do
        if command -v "$tool" &> /dev/null; then
            print_success "$tool trouvÃ©: $(command -v "$tool")"
        else
            missing+=("$tool")
            print_error "$tool non trouvÃ©"
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        print_error "Outils manquants: ${missing[*]}"
        print_info "Installez-les avec:"
        echo "sudo apt update && sudo apt install -y ${missing[*]}"
        return 1
    fi
}

check_project_structure() {
    print_step "VÃ©rification de la structure du projet..."
    
    # VÃ©rifier qu'on est dans le bon rÃ©pertoire avec les charts Ã  la racine
    local expected_charts=("bind9" "database" "email" "monitoring" "unbound" "web-apache" "web-nginx")
    local missing_charts=()
    
    for chart in "${expected_charts[@]}"; do
        if [[ ! -d "$chart" ]]; then
            missing_charts+=("$chart")
        fi
    done
    
    if [[ ${#missing_charts[@]} -gt 0 ]]; then
        print_error "Charts manquants: ${missing_charts[*]}"
        print_info "Assurez-vous d'Ãªtre dans le rÃ©pertoire racine du projet helm-web-services-charts"
        return 1
    fi
    
    print_success "Structure de charts trouvÃ©e Ã  la racine"
    
    # Lister les charts disponibles avec validation Chart.yaml
    echo ""
    print_info "Charts Helm dÃ©tectÃ©s:"
    
    declare -A chart_paths=(
        ["bind9"]="bind9"
        ["mysql"]="database/mysql"
        ["phpmyadmin"]="database/phpmyadmin"
        ["email"]="email"
        ["monitoring"]="monitoring/monitoring-chart"
        ["unbound"]="unbound"
        ["web-apache"]="web-apache"
        ["web-nginx"]="web-nginx"
    )
    
    for chart_name in "${!chart_paths[@]}"; do
        chart_path="${chart_paths[$chart_name]}"
        if [[ -f "$chart_path/Chart.yaml" ]]; then
            print_success "$chart_name ($chart_path)"
        else
            print_error "$chart_name - Chart.yaml manquant dans $chart_path"
        fi
    done
}

check_minikube_status() {
    print_step "VÃ©rification de l'environnement Minikube..."
    
    if minikube status &> /dev/null; then
        print_success "Minikube est actif"
        print_info "Profil: $(minikube profile)"
        if command -v kubectl &> /dev/null; then
            local k8s_version=$(kubectl version --client --short 2>/dev/null | grep "Client Version" | cut -d' ' -f3 || echo "unknown")
            print_info "Version kubectl: $k8s_version"
        fi
    else
        print_warning "Minikube n'est pas actif"
        echo ""
        read -p "ğŸš€ DÃ©marrer Minikube maintenant ? [y/N]: " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            print_info "DÃ©marrage de Minikube..."
            minikube start --driver=docker --memory=4096 --cpus=2
            print_success "Minikube dÃ©marrÃ©!"
        else
            print_info "Minikube restera inactif (vous pourrez le dÃ©marrer plus tard)"
        fi
    fi
}

setup_github_config() {
    print_step "Configuration GitHub..."
    
    # Auto-dÃ©tection du repo Git
    if [[ -d ".git" ]]; then
        REMOTE_URL=$(git remote get-url origin 2>/dev/null || echo "")
        if [[ "$REMOTE_URL" =~ github\.com[:/]([^/]+)/([^/.]+) ]]; then
            AUTO_OWNER="${BASH_REMATCH[1]}"
            AUTO_REPO="${BASH_REMATCH[2]}"
            print_success "Repo dÃ©tectÃ© automatiquement: $AUTO_OWNER/$AUTO_REPO"
            
            # Mise Ã  jour du fichier de config
            if [[ -f "ansible/ansible-minikube-config.yml" ]]; then
                sed -i "s/VOTRE_USERNAME/$AUTO_OWNER/g" ansible/ansible-minikube-config.yml 2>/dev/null || true
                sed -i "s/ansible-lab/$AUTO_REPO/g" ansible/ansible-minikube-config.yml 2>/dev/null || true
                print_success "Configuration mise Ã  jour automatiquement"
            fi
            
        else
            print_warning "Impossible de dÃ©tecter le repo GitHub depuis l'URL Git"
        fi
    else
        print_warning "Pas de repo Git dÃ©tectÃ©"
    fi
    
    # Configuration du token
    if [[ -z "$GITHUB_PAT" ]]; then
        print_warning "Variable GITHUB_PAT non dÃ©finie"
        print_info "Pour configurer le token GitHub:"
        echo "  1. Allez sur https://github.com/settings/tokens"
        echo "  2. CrÃ©ez un token avec scopes: repo, workflow"
        echo "  3. Exportez-le: export GITHUB_PAT='your_token_here'"
        echo ""
        read -p "ğŸ“‹ Avez-vous dÃ©jÃ  un token GitHub ? [y/N]: " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            read -p "ğŸ”‘ Collez votre token (masquÃ©): " -s github_token
            echo ""
            export GITHUB_PAT="$github_token"
            print_success "Token configurÃ© pour cette session"
        fi
    else
        print_success "Token GitHub dÃ©tectÃ©"
    fi
}

create_workflow_files() {
    print_step "CrÃ©ation des fichiers workflow..."
    
    # CrÃ©er le rÃ©pertoire .github/workflows s'il n'existe pas
    mkdir -p .github/workflows
    
    # VÃ©rifier si les workflows existent dÃ©jÃ 
    if [[ -f ".github/workflows/helm-full-check.yml" ]]; then
        print_success "Workflow CI dÃ©jÃ  prÃ©sent"
    else
        print_warning "Workflow CI manquant"
        print_info "Copiez le contenu du workflow helm-full-check.yml dans .github/workflows/"
    fi
    
    # VÃ©rifier si le workflow helm-check.yml existe aussi
    if [[ -f ".github/workflows/helm-check.yml" ]]; then
        print_info "Workflow helm-check.yml Ã©galement prÃ©sent"
    fi
}

test_ci_trigger() {
    print_step "Test du dÃ©clenchement CI..."
    
    if [[ -z "$GITHUB_PAT" ]]; then
        print_warning "Impossible de tester sans token GitHub"
        return 0
    fi
    
    print_info "Test en mode dry-run..."
    
    # Test avec le playbook Ansible
    if [[ -f "ansible/minikube-ci-trigger.yml" ]]; then
        if ansible-playbook ansible/minikube-ci-trigger.yml --check -v > /dev/null 2>&1; then
            print_success "Playbook Ansible validÃ©"
        else
            print_warning "Playbook nÃ©cessite des ajustements (normal en dry-run)"
        fi
    else
        print_warning "Playbook minikube-ci-trigger.yml non trouvÃ©"
    fi
}

show_next_steps() {
    print_step "Prochaines Ã©tapes..."
    
    echo ""
    print_info "ğŸ¯ Pour dÃ©clencher le CI:"
    echo "  # MÃ©thode recommandÃ©e: Playbook Ansible"
    echo "  ansible-playbook ansible/minikube-ci-trigger.yml -e check_type=full"
    echo ""
    echo "  # Autres options de vÃ©rification:"
    echo "  ansible-playbook ansible/minikube-ci-trigger.yml -e check_type=security-only"
    echo "  ansible-playbook ansible/minikube-ci-trigger.yml -e check_type=lint-only"
    echo ""
    
    print_info "ğŸ” Types de vÃ©rification disponibles:"
    echo "  - full          : Validation complÃ¨te (recommandÃ©)"
    echo "  - security-only : Audit sÃ©curitÃ© uniquement" 
    echo "  - lint-only     : Lint YAML uniquement"
    echo ""
    
    print_info "ğŸ“¦ Charts qui seront validÃ©s:"
    echo "  - bind9 (DNS)"
    echo "  - mysql + phpmyadmin (Database)"
    echo "  - email (Mail server)"
    echo "  - monitoring (Prometheus + Grafana)"
    echo "  - unbound (DNS resolver)"
    echo "  - web-apache + web-nginx (Web servers)"
    echo ""
    
    print_info "ğŸ“‹ Workflow du projet:"
    echo "  1. ğŸ” CI validation (GitHub Actions) â† Vous Ãªtes ici"
    echo "  2. âœ… Si OK â†’ PrÃªt pour dÃ©ploiement manuel"
    echo "  3. ğŸš€ DÃ©ploiement sur Minikube (manuel pour l'instant)"
    echo "  4. ğŸ“Š Monitoring des services"
    echo ""
    
    if [[ -n "$AUTO_OWNER" && -n "$AUTO_REPO" ]]; then
        print_info "ğŸŒ Liens utiles:"
        echo "  - Actions GitHub: https://github.com/$AUTO_OWNER/$AUTO_REPO/actions"
        echo "  - Dashboard Minikube: minikube dashboard"
        echo "  - Logs Kubectl: kubectl logs -f deployment/{service}"
    fi
}

# Execution principale
main() {
    print_header
    
    print_info "ğŸ¯ Setup pour projet: Ansible + Docker + Kubernetes + Helm + CI"
    print_info "ğŸ—ï¸ Environnement cible: Debian 12 + Minikube"
    print_info "ğŸ“¦ Charts dÃ©tectÃ©s: 8 services (DNS, DB, Web, Email, Monitoring)"
    echo ""
    
    check_prerequisites || exit 1
    echo ""
    
    check_project_structure || exit 1
    echo ""
    
    check_minikube_status
    echo ""
    
    setup_github_config
    echo ""
    
    create_workflow_files
    echo ""
    
    test_ci_trigger
    echo ""
    
    show_next_steps
    
    echo ""
    print_success "ğŸ‰ Setup terminÃ©!"
    print_info "Vous pouvez maintenant dÃ©clencher votre CI Helm Charts!"
    echo ""
    print_info "Commande rapide:"
    echo "export GITHUB_PAT='your_token' && ansible-playbook ansible/minikube-ci-trigger.yml -e check_type=full"
}

# Point d'entrÃ©e
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
